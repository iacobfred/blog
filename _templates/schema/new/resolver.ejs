---
to: graphql/generated/resolvers/<%= name %>.resolver.ts
force: true
---
<% names = h.inflection.pluralize(name); -%>
<% Names = h.inflection.pluralize(Name); -%>
/* Do not edit this file. It was generated programmatically. */

import * as TypeGraphQL from "type-graphql-v2-fork";
import <%= Name %> from "@web/graphql/generated/types/<%= Name %>";
import <%= Name %>Model from "@web/graphql/generated/models/<%= Name %>Model";
import {
  <%= Name %>CreationArgs,
  <%= Names %>CreationArgs,
  Delete<%= Name %>Args,
  DeleteMany<%= Name %>Args,
  FindMany<%= Name %>Args,
  FindUnique<%= Name %>Args,
  <%= Name %>UpdateArgs,
  ArgsForUpdatingMany<%= Names %>,
  <%= Name %>UpsertionArgs,
} from "@web/graphql/generated/args/<%= name %>.args";
import { GqlContext } from "@web/graphql/context";
import { GraphQLResolveInfo } from "graphql";
import { convertFilterForMongo } from "@web/graphql/schema/helpers";
import { ObjectIdScalar } from "@web/graphql/schema/scalars";
<% if (Object.keys(fields).includes("userId")) { -%>
import UserModel from "@web/graphql/generated/models/UserModel";
<% } -%>

@TypeGraphQL.Resolver(() => <%= Name %>)
export class <%= Name %>Resolver {
  @TypeGraphQL.FieldResolver(() => ObjectIdScalar)
  id(@TypeGraphQL.Root() <%= name %>: <%= Name %>) {
    return <%= name %>._id;
  }

  @TypeGraphQL.Query(() => <%= Name %>, { nullable: true })
  async <%= name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindUnique<%= Name %>Args
  ): Promise<<%= Name %> | null> {
    const filter = convertFilterForMongo(args.where);
    return <%= Name %>Model.findOne(filter);
  }

  @TypeGraphQL.Query(() => [<%= Name %>], { nullable: false })
  async <%= names %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindMany<%= Name %>Args
  ): Promise<<%= Name %>[]> {
    const filter = convertFilterForMongo(args.where);
    return <%= Name %>Model.find(filter ?? {});
  }

  @TypeGraphQL.Mutation(() => <%= Name %>)
  async create<%= Name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: <%= Name %>CreationArgs
  ) {
    const <%= name %> = await <%= Name %>Model.create(args.data);
<% if (Object.keys(fields).includes("userId")) { -%>
    if (<%= name %>) {
      // NOTE: This update fails if it's not awaited.
      await UserModel.findOneAndUpdate(
        { _id: <%= name %>.userId },
        { $push: { <%= names %>: { ...<%= name %> } } },
      );
    }
<% } -%>
    return <%= name %>;
  }

  @TypeGraphQL.Mutation(() => [<%= Name %>], { nullable: false })
  async createMany<%= Name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: <%= Names %>CreationArgs
  ): Promise<<%= Name %>[]> {
    throw new Error("Not implemented");
  }

  @TypeGraphQL.Mutation(() => <%= Name %>)
  async update<%= Name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: <%= Name %>UpdateArgs
  ) {
    const filter = convertFilterForMongo(args.where);
    const <%= name %> = await <%= Name %>Model.findOneAndUpdate(filter, args.data, { returnDocument: "after" });
<% if (Object.keys(fields).includes("userId")) { -%>
    // NOTE: This update fails if it's not awaited.
    <%= name %> && await UserModel.findOneAndUpdate({ _id: <%= name %>.userId, "<%= names %>._id": <%= name %>._id }, {
      $set: { "<%= names %>.$": { ...<%= name %> } }
    });
<% } -%>
    return <%= name %>;
  }

  @TypeGraphQL.Mutation(() => <%= Name %>)
  async upsert<%= Name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: <%= Name %>UpsertionArgs
  ) {
    const filter = convertFilterForMongo(args.where);
    const <%= name %> = await <%= Name %>Model.findOneAndUpdate(filter, args.data, {
      upsert: true,
      new: true,
      returnDocument: "after",
    });
    return <%= name %>;
  }

  @TypeGraphQL.Mutation(() => [<%= Name %>], { nullable: false })
  async update<%= Names %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: ArgsForUpdatingMany<%= Names %>
  ): Promise<<%= Name %>[]> {
    throw new Error("Not implemented");
  }

  @TypeGraphQL.Mutation(() => [<%= Name %>], { nullable: false })
  async update<%= Names %>Distinctly(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: ArgsForUpdatingMany<%= Names %>
  ): Promise<<%= Name %>[]> {
    throw new Error("Not implemented");
  }

  @TypeGraphQL.Mutation(() => <%= Name %>, { nullable: true })
  async delete<%= Name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: Delete<%= Name %>Args
  ): Promise<<%= Name %> | null> {
    throw new Error("Not implemented");
  }

  @TypeGraphQL.Mutation(() => [<%= Name %>], { nullable: false })
  async deleteMany<%= Name %>(
    @TypeGraphQL.Ctx() ctx: GqlContext,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: DeleteMany<%= Name %>Args
  ): Promise<<%= Name %>[]> {
    throw new Error("Not implemented");
  }
}
